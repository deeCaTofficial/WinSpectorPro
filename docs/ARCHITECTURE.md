# Архитектура проекта WinSpector Pro v1.0.2

Этот документ описывает внутреннее устройство, ключевые архитектурные решения и потоки данных в проекте WinSpector Pro.

## 1. Обзор

**WinSpector Pro** — это десктопное приложение для анализа и автономной оптимизации Windows. Оно построено на Python с использованием фреймворка PyQt6. Ключевая особенность проекта — глубокая интеграция с генеративным ИИ (Google Gemini) для принятия интеллектуальных, персонализированных и безопасных решений по оптимизации.

Проект следует многослойной архитектуре для четкого разделения ответственности (представление, логика, данные), что упрощает его поддержку, тестирование и дальнейшее развитие.

## 2. Технологический стек

- **Язык:** Python 3.10+
- **GUI:** PyQt6
- **Асинхронность:** `asyncio` для параллельного выполнения задач + `qasync` для интеграции с циклом событий PyQt6.
- **Системное взаимодействие:** `psutil`, `pywin32`, `wmi`.
- **ИИ-интеграция:** Google Generative AI API (`google-generativeai`).
- **Работа с данными:** `PyYAML` для конфигураций и базы знаний.
- **Сборка:** PyInstaller.
- **Тестирование:** `pytest` с плагинами `pytest-qt` и `pytest-asyncio`.

## 3. Структура слоев и компонентов

Проект разделен на три основных логических слоя, которые взаимодействуют друг с другом по четко определенным API.

### 3.1. Уровень представления (GUI Layer)

- **Расположение:** `src/winspector/gui/`
- **Ответственность:** Отображение информации и обработка действий пользователя. Этот слой не содержит бизнес-логики; он лишь делегирует команды ядру и отображает результаты.
- **Ключевые компоненты:**
    - `main_window.py`: Главное окно приложения. Управляет страницами (виджетами), запускает асинхронные задачи через `AsyncWorker` и обрабатывает сигналы от них.
    - `AsyncWorker` (внутри `main_window.py`): Специализированный `QThread`, который безопасно выполняет асинхронные корутины ядра. Решает проблему многопоточности с COM/WMI через `pythoncom.CoInitialize()`.
    - `widgets/`: Каталог с кастомными виджетами (`PulsingButton`) для создания динамичного интерфейса.
    - `icon_generator.py`: Модуль для программной генерации иконок, что уменьшает зависимость от внешних файлов ресурсов.

### 3.2. Уровень ядра (Core Layer)

- **Расположение:** `src/winspector/core/analyzer.py`
- **Ответственность:** Оркестрация всего процесса оптимизации. Реализует паттерн **Фасад**, предоставляя простой интерфейс (`run_autonomous_optimization`) для сложной внутренней логики.
- **Ключевые компоненты:**
    - `WinSpectorCore`: Центральный класс, который инициализирует все аналитические модули, управляет потоком данных между ними и реализует основной сценарий оптимизации.

### 3.3. Уровень модулей анализа (Modules Layer)

- **Расположение:** `src/winspector/core/modules/`
- **Ответственность:** Выполнение конкретных, узкоспециализированных задач анализа и оптимизации. Модули спроектированы так, чтобы быть максимально независимыми.
- **Ключевые компоненты:**
    - `ai_analyzer.py`: **"Мозг" приложения.** Отправляет запросы к API Gemini для:
        1.  Определения профиля пользователя.
        2.  Генерации JSON-плана оптимизации на основе системных данных.
        3.  Создания человекочитаемых отчетов.
    - `user_profiler.py`: Собирает неперсональный "цифровой отпечаток" системы (установленное ПО, оборудование, маркеры использования) для передачи в ИИ.
    - `windows_optimizer.py`: Ищет кандидатов на оптимизацию (службы, UWP-приложения) и выполняет сгенерированный ИИ план через PowerShell.
    - `smart_cleaner.py`: Выполняет эвристический поиск и очистку "мусорных" файлов (кэши, логи, временные файлы).

### 3.4. Уровень данных и конфигурации

- **Расположение:** `src/winspector/data/`
- **Ответственность:** Хранение статических данных и конфигураций.
- **Ключевые компоненты:**
    - `knowledge_base.yaml`: **База знаний.** Содержит критически важные списки (например, службы, которые нельзя отключать), правила для эвристики и другие данные, которые ИИ использует для принятия безопасных решений.
    - `telemetry_domains.txt`: Список доменов для блокировки (функционал для будущих версий).
    - `config.py`: Конфигурация модулей, которая может быть использована по умолчанию.

## 4. Поток данных в сценарии автономной оптимизации

1.  **Инициация (GUI):** Пользователь нажимает кнопку "Начать дистилляцию". `MainWindow` создает `AsyncWorker` и запускает в нем метод `WinSpectorCore.run_autonomous_optimization()`.
2.  **Точка восстановления (WindowsOptimizer):** Создается точка восстановления системы через PowerShell.
3.  **Профилирование (UserProfiler):** Собираются данные об аппаратном обеспечении и установленных программах.
4.  **Анализ профиля (AIAnalyzer):** Собранные данные отправляются в Gemini. ИИ возвращает профиль пользователя (например, "Gamer").
5.  **Глубокий сбор данных (WOpt, SmartCleaner):** Параллельно запускаются задачи по сбору информации о службах, UWP-приложениях и поиску "мусорных" файлов.
6.  **Генерация плана (AIAnalyzer):** Все собранные данные вместе с профилем пользователя и базой знаний (`knowledge_base.yaml`) отправляются в Gemini с комплексным промптом. ИИ возвращает **структурированный JSON-объект**, содержащий `action_plan` и `cleanup_plan`.
7.  **Валидация плана (WinSpectorCore):** Ядро проверяет, что полученный JSON-план имеет корректную структуру.
8.  **Исполнение (WindowsOptimizer, SmartCleaner):**
    - `WindowsOptimizer` генерирует и выполняет PowerShell-скрипт на основе `action_plan`.
    - `SmartCleaner` удаляет файлы на основе `cleanup_plan`.
9.  **Отчет (AIAnalyzer -> GUI):** Результаты выполнения (сколько служб отключено, сколько места освобождено) отправляются в Gemini для генерации дружелюбного отчета в формате Markdown. Отчет отображается в `QTextBrowser` на `MainWindow`.

## 5. Ключевые архитектурные решения v1.0.0

- **Lazy Initialization для WMI:** Объекты WMI создаются не в конструкторах модулей, а при первом обращении к ним через `property`. Это решает проблему с использованием COM-объектов в разных потоках, так как инициализация происходит в том же потоке, где и использование.
- **AI-Driven JSON Plan:** Вместо жестко закодированных правил, приложение полагается на ИИ для генерации динамического плана действий в формате JSON. Это делает систему гибкой и легко расширяемой.
- **Внешняя "База знаний":** Критически важные правила безопасности вынесены в `knowledge_base.yaml`. Это позволяет обновлять логику безопасности без изменения кода Python и делает систему более прозрачной.
- **Атомарность операций:** Весь процесс оптимизации рассматривается как одна большая транзакция, для отката которой используется системный механизм точек восстановления.